/*
 * WobbleBoardApp.cpp
 *
 *  Created on: Feb 19, 2022
 *      Author: Beca Vessal
 */

#include "WobbleBoardApp.h"

#include "motion_fx_manager.h"
#include "com.h"

#include "serial_cmd.h"

#define ALGO_FREQ  100U /* Algorithm frequency 100Hz */
#define ACC_ODR  ((float)ALGO_FREQ)
#define ACC_FS  4 /* FS = <-4g, 4g> */
#define ALGO_PERIOD  (1000U / ALGO_FREQ) /* Algorithm period [ms] */

#define ACCELEROMETER_SENSOR  0x00000010U
#define GYROSCOPE_SENSOR      0x00000020U
#define MAGNETIC_SENSOR       0x00000040U

#define MOTION_FX_ENGINE_DELTATIME  0.01f

#define FROM_MG_TO_G  0.001f
#define FROM_G_TO_MG  1000.0f
#define FROM_MDPS_TO_DPS  0.001f
#define FROM_DPS_TO_MDPS  1000.0f
#define FROM_MGAUSS_TO_UT50  (0.1f/50.0f)
#define FROM_UT50_TO_MGAUSS  500.0f

#define STREAMING_MSG_LENGTH  119

#define DEV_ADDR  50U

WobbleBoardApp::WobbleBoardApp()
{
	// TODO Auto-generated constructor stub

}

void WobbleBoardApp::Init()
{
	InitInertialSensors();

	// Sensor Fusion API initialization function
	MotionFX_manager_init();

	//Enable magnetometer calibration
	MotionFX_manager_MagCal_start(ALGO_PERIOD);

	/* Test if calibration data are available */
	MFX_MagCal_output_t mag_cal_test;
	MotionFX_MagCal_getParams(&mag_cal_test);

	// If calibration data are available load HI coefficients
	if (mag_cal_test.cal_quality == MFX_MAGCALGOOD)
	{
		float ans_float;
		ans_float = (mag_cal_test.hi_bias[0] * FROM_UT50_TO_MGAUSS);
		MagOffset.x = (int32_t)ans_float;
		ans_float = (mag_cal_test.hi_bias[1] * FROM_UT50_TO_MGAUSS);
		MagOffset.y = (int32_t)ans_float;
		ans_float = (mag_cal_test.hi_bias[2] * FROM_UT50_TO_MGAUSS);
		MagOffset.z = (int32_t)ans_float;

		MagCalStatus = 1;
	}

	// Start receiving messages via DMA
	UART_StartReceiveMsg();
}

void WobbleBoardApp::InitInertialSensors()
{
	BSP_SENSOR_ACC_Init();
	BSP_SENSOR_GYR_Init();
	BSP_SENSOR_MAG_Init();

	BSP_SENSOR_ACC_SetOutputDataRate(ACC_ODR);
	BSP_SENSOR_ACC_SetFullScale(ACC_FS);
}

void WobbleBoardApp::Process()
{
	TMsg msg_dat;
	TMsg msg_cmd;

	if (UART_ReceivedMSG((TMsg *)&msg_cmd) == 1)
	{
		if (msg_cmd.Data[0] == DEV_ADDR)
		{
		  HandleMSG((TMsg *)&msg_cmd);
		}
	}

	if (MagCalRequest == 1U)
	{
		MagCalRequest = 0;

		/* Reset magnetometer calibration value*/
		MagCalStatus = 0;
		MagOffset.x = 0;
		MagOffset.y = 0;
		MagOffset.z = 0;

		/* Enable magnetometer calibration */
		MotionFX_manager_MagCal_start(ALGO_PERIOD);
	}

	if (SensorReadRequest == 1U)
	{
		SensorReadRequest = 0;

		/* Acquire data from enabled sensors and fill Msg stream */
		//RTC_Handler(&msg_dat);
		Accelero_Sensor_Handler(&msg_dat);
		Gyro_Sensor_Handler(&msg_dat);
		Magneto_Sensor_Handler(&msg_dat);

		/* Sensor Fusion specific part */
		FX_Data_Handler(&msg_dat);

		/* Send data stream */
		Init_Streaming_Header(&msg_dat);
		msg_dat.Len = STREAMING_MSG_LENGTH;
	}
	UART_SendMsg(&msg_dat);
}

void WobbleBoardApp::Accelero_Sensor_Handler(TMsg* Msg)
{
	if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
	{

		BSP_SENSOR_ACC_GetAxes(&AccValue);

		Serialize_s32(&Msg->Data[19], (int32_t)AccValue.x, 4);
		Serialize_s32(&Msg->Data[23], (int32_t)AccValue.y, 4);
		Serialize_s32(&Msg->Data[27], (int32_t)AccValue.z, 4);
	}
}

void WobbleBoardApp::Gyro_Sensor_Handler(TMsg* Msg)
{
	if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
	{
		BSP_SENSOR_GYR_GetAxes(&GyrValue);

		Serialize_s32(&Msg->Data[31], GyrValue.x, 4);
		Serialize_s32(&Msg->Data[35], GyrValue.y, 4);
		Serialize_s32(&Msg->Data[39], GyrValue.z, 4);
	}
}

void WobbleBoardApp::Magneto_Sensor_Handler(TMsg* Msg)
{
	float ans_float;
	MFX_MagCal_input_t mag_data_in;
	MFX_MagCal_output_t mag_data_out;

	if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
	{
		BSP_SENSOR_MAG_GetAxes(&MagValue);

		if (MagCalStatus == 0U)
		{
			mag_data_in.mag[0] = (float)MagValue.x * FROM_MGAUSS_TO_UT50;
			mag_data_in.mag[1] = (float)MagValue.y * FROM_MGAUSS_TO_UT50;
			mag_data_in.mag[2] = (float)MagValue.z * FROM_MGAUSS_TO_UT50;

			mag_data_in.time_stamp = (int)TimeStamp;
			TimeStamp += (uint32_t)ALGO_PERIOD;

			MotionFX_manager_MagCal_run(&mag_data_in, &mag_data_out);

			if (mag_data_out.cal_quality == MFX_MAGCALGOOD)
			{
				MagCalStatus = 1;

				ans_float = (mag_data_out.hi_bias[0] * FROM_UT50_TO_MGAUSS);
				MagOffset.x = (int32_t)ans_float;
				ans_float = (mag_data_out.hi_bias[1] * FROM_UT50_TO_MGAUSS);
				MagOffset.y = (int32_t)ans_float;
				ans_float = (mag_data_out.hi_bias[2] * FROM_UT50_TO_MGAUSS);
				MagOffset.z = (int32_t)ans_float;

				/* Disable magnetometer calibration */
				MotionFX_manager_MagCal_stop(ALGO_PERIOD);
			}
		}

		MagValue.x = (int32_t)(MagValue.x - MagOffset.x);
		MagValue.y = (int32_t)(MagValue.y - MagOffset.y);
		MagValue.z = (int32_t)(MagValue.z - MagOffset.z);

		Serialize_s32(&Msg->Data[43], MagValue.x, 4);
		Serialize_s32(&Msg->Data[47], MagValue.y, 4);
		Serialize_s32(&Msg->Data[51], MagValue.z, 4);
	}
}

void WobbleBoardApp::FX_Data_Handler(TMsg* Msg)
{
	uint32_t elapsed_time_us = 0U;
	MFX_input_t data_in;
	MFX_input_t *pdata_in = &data_in;
	MFX_output_t data_out;
	MFX_output_t *pdata_out = &data_out;

	if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
	{
		if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
		{
			if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
			{
				/* Convert angular velocity from [mdps] to [dps] */
				data_in.gyro[0] = (float)GyrValue.x * FROM_MDPS_TO_DPS;
				data_in.gyro[1] = (float)GyrValue.y * FROM_MDPS_TO_DPS;
				data_in.gyro[2] = (float)GyrValue.z * FROM_MDPS_TO_DPS;

				/* Convert acceleration from [mg] to [g] */
				data_in.acc[0] = (float)AccValue.x * FROM_MG_TO_G;
				data_in.acc[1] = (float)AccValue.y * FROM_MG_TO_G;
				data_in.acc[2] = (float)AccValue.z * FROM_MG_TO_G;

				/* Convert magnetic field intensity from [mGauss] to [uT / 50] */
				data_in.mag[0] = (float)MagValue.x * FROM_MGAUSS_TO_UT50;
				data_in.mag[1] = (float)MagValue.y * FROM_MGAUSS_TO_UT50;
				data_in.mag[2] = (float)MagValue.z * FROM_MGAUSS_TO_UT50;

				/* Run Sensor Fusion algorithm */
				DWT_Start();
				MotionFX_manager_run(pdata_in, pdata_out, MOTION_FX_ENGINE_DELTATIME);
				elapsed_time_us = DWT_Stop();

				(void)memcpy(&Msg->Data[55], (void *)pdata_out->quaternion, 4U * sizeof(float));
				(void)memcpy(&Msg->Data[71], (void *)pdata_out->rotation, 3U * sizeof(float));
				(void)memcpy(&Msg->Data[83], (void *)pdata_out->gravity, 3U * sizeof(float));
				(void)memcpy(&Msg->Data[95], (void *)pdata_out->linear_acceleration, 3U * sizeof(float));

				(void)memcpy(&Msg->Data[107], (void *) & (pdata_out->heading), sizeof(float));
				(void)memcpy(&Msg->Data[111], (void *) & (pdata_out->headingErr), sizeof(float));

				Serialize_s32(&Msg->Data[115], (int32_t)elapsed_time_us, 4);
			}
		}
	}
}

/**
 * @brief  Initialize DWT register for counting clock cycles purpose
 * @param  None
 * @retval None
 */
void WobbleBoardApp::DWT_Init()
{
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;

	DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; /* Disable counter */
}

void WobbleBoardApp::DWT_Start()
{
	DWT->CYCCNT = 0; /* Clear count of clock cycles */
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk; /* Enable counter */
}

/**
 * @brief  Stop counting clock cycles and calculate elapsed time in [us]
 * @param  None
 * @retval Elapsed time in [us]
 */
uint32_t WobbleBoardApp::DWT_Stop()
{
	volatile uint32_t cycles_count = 0U;
	uint32_t system_core_clock_mhz = 0U;

	DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; /* Disable counter */
	cycles_count = DWT->CYCCNT; /* Read count of clock cycles */

	/* Calculate elapsed time in [us] */
	system_core_clock_mhz = SystemCoreClock / 1000000U;
	return cycles_count / system_core_clock_mhz;
}

void WobbleBoardApp::Init_Streaming_Header(TMsg* Msg)
{
	Msg->Data[0] = DataStreamingDest;
	Msg->Data[1] = DEV_ADDR;
	Msg->Data[2] = CMD_Start_Data_Streaming;
	Msg->Len = 3;
}

/**
 * @brief  Handle a message
 * @param  Msg the pointer to the message to be handled
 * @retval 1 if the message is correctly handled, 0 otherwise
 */
int WobbleBoardApp::HandleMSG(TMsg* Msg)
{
/*  DestAddr | SouceAddr | CMD | PAYLOAD
 *      1          1        1       N
 */
  int ret = 1;
  uint32_t i;
  char ps[64];
  uint32_t ps_len = 0;
  static uint32_t sensors_enabled_prev = 0;
  int32_t msg_offset;
  uint32_t msg_count;

  if (Msg->Len < 2U)
  {
	return 0;
  }

  if (Msg->Data[0] != DEV_ADDR)
  {
	return 0;
  }

  switch (Msg->Data[2])   /* CMD */
  {
//	case CMD_ACCELERO_GYRO_Init:
//	  if (Msg->Len < 3U)
//	  {
//		return 0;
//	  }
//
//	  BUILD_REPLY_HEADER(Msg);
//	  Serialize_s32(&Msg->Data[3], ACC_GYR_UNICLEO_ID, 4);
//	  Msg->Len = 3 + 4;
//	  UART_SendMsg(Msg);
//	  break;
//
//	case CMD_MAGNETO_Init:
//	  if (Msg->Len < 3U)
//	  {
//		return 0;
//	  }

	  BUILD_REPLY_HEADER(Msg);
	  Serialize_s32(&Msg->Data[3], MAG_UNICLEO_ID, 4);
	  Msg->Len = 3 + 4;
	  UART_SendMsg(Msg);
	  break;

	case CMD_Start_Data_Streaming:
	  if (Msg->Len < 3U)
	  {
		return 0;
	  }

	  SensorsEnabled = Deserialize(&Msg->Data[3], 4);

	  /* Start enabled sensors */
	  if ((SensorsEnabled & PRESSURE_SENSOR) == PRESSURE_SENSOR)
	  {
		BSP_SENSOR_PRESS_Enable();
	  }

	  if ((SensorsEnabled & TEMPERATURE_SENSOR) == TEMPERATURE_SENSOR)
	  {
		BSP_SENSOR_TEMP_Enable();
	  }

	  if ((SensorsEnabled & HUMIDITY_SENSOR) == HUMIDITY_SENSOR)
	  {
		BSP_SENSOR_HUM_Enable();
	  }

	  if ((SensorsEnabled & ACCELEROMETER_SENSOR) == ACCELEROMETER_SENSOR)
	  {
		BSP_SENSOR_ACC_Enable();
	  }

	  if ((SensorsEnabled & GYROSCOPE_SENSOR) == GYROSCOPE_SENSOR)
	  {
		BSP_SENSOR_GYR_Enable();
	  }

	  if ((SensorsEnabled & MAGNETIC_SENSOR) == MAGNETIC_SENSOR)
	  {
		BSP_SENSOR_MAG_Enable();
	  }

	  (void)HAL_TIM_Base_Start_IT(&BSP_IP_TIM_Handle);
	  DataLoggerActive = 1;

	  DataStreamingDest = Msg->Data[1];
	  BUILD_REPLY_HEADER(Msg);
	  Msg->Len = 3;
	  UART_SendMsg(Msg);
	  break;

	case CMD_Stop_Data_Streaming:
	  if (Msg->Len < 3U)
	  {
		return 0;
	  }

	  DataLoggerActive = 0;
	  (void)HAL_TIM_Base_Stop_IT(&BSP_IP_TIM_Handle);

	  /* Disable all sensors */
	  BSP_SENSOR_ACC_Disable();
	  BSP_SENSOR_GYR_Disable();
	  BSP_SENSOR_MAG_Disable();
	  BSP_SENSOR_PRESS_Disable();
	  BSP_SENSOR_TEMP_Disable();
	  BSP_SENSOR_HUM_Disable();

	  SensorsEnabled = 0;
	  UseOfflineData = 0;

	  BUILD_REPLY_HEADER(Msg);
	  UART_SendMsg(Msg);
	  break;

	case CMD_Set_DateTime:
	  if (Msg->Len < 3U)
	  {
		return 0;
	  }

	  BUILD_REPLY_HEADER(Msg);
	  Msg->Len = 3;
	  RTC_TimeRegulate(Msg->Data[3], Msg->Data[4], Msg->Data[5]);
	  RTC_DateRegulate(Msg->Data[6], Msg->Data[7], Msg->Data[8], Msg->Data[9]);
	  UART_SendMsg(Msg);
	  break;

	case CMD_Offline_Data:
	  if (Msg->Len < 55U)
	  {
		return 0;
	  }

	  msg_offset = 4;
	  msg_count = (uint32_t)Msg->Data[3];

	  for (i = 0; i < msg_count; i++)
	  {
		memcpy(&OfflineData[OfflineDataWriteIndex].hours, &Msg->Data[msg_offset], 1);
		memcpy(&OfflineData[OfflineDataWriteIndex].minutes, &Msg->Data[msg_offset + 1], 1);
		memcpy(&OfflineData[OfflineDataWriteIndex].seconds, &Msg->Data[msg_offset + 2], 1);
		memcpy(&OfflineData[OfflineDataWriteIndex].subsec, &Msg->Data[msg_offset + 3], 1);

		memcpy(&OfflineData[OfflineDataWriteIndex].pressure, &Msg->Data[msg_offset + 4], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].temperature, &Msg->Data[msg_offset + 8], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].humidity, &Msg->Data[msg_offset + 12], 4);

		memcpy(&OfflineData[OfflineDataWriteIndex].acceleration_x_mg, &Msg->Data[msg_offset + 16], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].acceleration_y_mg, &Msg->Data[msg_offset + 20], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].acceleration_z_mg, &Msg->Data[msg_offset + 24], 4);

		memcpy(&OfflineData[OfflineDataWriteIndex].angular_rate_x_mdps, &Msg->Data[msg_offset + 28], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].angular_rate_y_mdps, &Msg->Data[msg_offset + 32], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].angular_rate_z_mdps, &Msg->Data[msg_offset + 36], 4);

		memcpy(&OfflineData[OfflineDataWriteIndex].magnetic_field_x_mgauss, &Msg->Data[msg_offset + 40], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].magnetic_field_y_mgauss, &Msg->Data[msg_offset + 44], 4);
		memcpy(&OfflineData[OfflineDataWriteIndex].magnetic_field_z_mgauss, &Msg->Data[msg_offset + 48], 4);

		msg_offset += 52;

		OfflineDataCount++;
		if (OfflineDataCount > OFFLINE_DATA_SIZE)
		{
		  OfflineDataCount = OFFLINE_DATA_SIZE;
		}

		OfflineDataWriteIndex++;
		if (OfflineDataWriteIndex >= OFFLINE_DATA_SIZE)
		{
		  OfflineDataWriteIndex = 0;
		}
	  }

	  SensorReadRequest = 1;

	  /* Mark Msg as read */
	  BUILD_REPLY_HEADER(Msg);
	  Msg->Len = 3;
	  break;

	case CMD_Use_Offline_Data:
	  if (Msg->Len < 4U)
	  {
		return 0;
	  }

	  if (Msg->Data[3] == 1U)
	  {
		UseOfflineData = 1U;
		sensors_enabled_prev = SensorsEnabled;
		SensorsEnabled = 0xFFFFFFFFU;
		(void)HAL_TIM_Base_Stop_IT(&BSP_IP_TIM_Handle);
	  }
	  else
	  {
		UseOfflineData = 0U;
		SensorsEnabled = sensors_enabled_prev;
	  }

	  BUILD_REPLY_HEADER(Msg);
	  UART_SendMsg(Msg);
	  break;

	case CMD_Get_App_Info:
	  if (Msg->Len < 3U)
	  {
		return 0;
	  }

	  Serialize_s32(&Msg->Data[3], AlgoFreq, 4);
	  Serialize_s32(&Msg->Data[7], REQUIRED_DATA, 1);

	  BUILD_REPLY_HEADER(Msg);
	  Msg->Len = 3 + 5;
	  UART_SendMsg(Msg);
	  break;

	case CMD_ChangeSF:
	  if (Msg->Len < 3U)
	  {
		return 0;
	  }

	  Enabled6X = Msg->Data[3];

	  if (Enabled6X == 1U)
	  {
		MotionFX_manager_stop_9X();
		MotionFX_manager_start_6X();
	  }
	  else
	  {
		MotionFX_manager_stop_6X();
		MotionFX_manager_start_9X();
	  }

	  BUILD_REPLY_HEADER(Msg);
	  UART_SendMsg(Msg);
	  break;

	default:
	  ret = 0;
	  break;
  }

  return ret;
}

//WobbleBoardApp::~WobbleBoardApp()
//{
//	// TODO Auto-generated destructor stub
//}

